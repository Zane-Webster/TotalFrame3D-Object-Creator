#ifndef SRC_TRIANGLE_H_
#define SRC_TRIANGLE_H_

#pragma once

#include <iostream>
#include <vector>
#include <memory>

#include <SDL3/SDL.h>

#include <GL/glew.h>
#include <glm/glm.hpp>

#include "TotalFrame.h"
#include "Util.h"

/*
ABOUT:
A basic colored triangle. Contains vertices, vertex array and vertex buffer.
Typical lifecycle is construct, LoadVertices, Build then Render. 
*/

class Triangle {
    public:
        Triangle(std::vector<GLfloat> vertices, std::vector<GLfloat> true_vertices);
        // do NOT try using ~ deconstructor. i spent 4 hours debugging this. 
        void FreeAll();

        //////// BASIC FUNCTIONS
        // verifys vertex_array and vertex_buffer is valid (non-zero)
        bool Verify();
        void LoadVertices(std::vector<GLfloat> vertices, std::vector<GLfloat> true_vertices);
        void Build();
        void Render();
        std::string GetData();

        //////// MOVEMENT FUNCTIONS
        void SetPosition(glm::vec3 position, float aspect_ratio);

        //////// COLOR FUNCTIONS
        void SetColor(glm::vec3 color);

    private:
        std::shared_ptr<TF_TRIANGLE_VERTICES> vertices = std::make_shared<TF_TRIANGLE_VERTICES>();
        std::shared_ptr<TF_TRIANGLE_VERTICES> true_vertices = std::make_shared<TF_TRIANGLE_VERTICES>();
        std::shared_ptr<TF_TRIANGLE_VERTICES> translated_true_vertices = std::make_shared<TF_TRIANGLE_VERTICES>();
        GLuint vertex_array = 0;
        GLuint vertex_buffer = 0;

};

#endif // SRC_TRIANGLE_H_

#include "Triangle.h"

//=============================
// DEFAULT CONSTRUCTOR
//=============================

Triangle::Triangle(std::vector<GLfloat> p_vertices, std::vector<GLfloat> p_true_vertices) {
    Triangle::LoadVertices(p_vertices, p_true_vertices);
    Triangle::Build();
}

//=============================
// BASIC FUNCTIONS
//=============================

bool Triangle::Verify() {
    if (vertex_array == 0 || vertex_buffer == 0) return false;
    return true;
}

void Triangle::LoadVertices(std::vector<GLfloat> p_vertices, std::vector<GLfloat> p_true_vertices) {
    if (p_vertices.size() == 18) {
        std::copy(p_vertices.begin(), p_vertices.end(), vertices->begin());
        std::copy(p_true_vertices.begin(), p_true_vertices.end(), true_vertices->begin());
        *translated_true_vertices = *true_vertices;
    }
}

void Triangle::Build() {
    glGenVertexArrays(1, &vertex_array);
    glGenBuffers(1, &vertex_buffer);

    glBindVertexArray(vertex_array);
    
    glBindBuffer(GL_ARRAY_BUFFER, vertex_buffer);
    glBufferData(GL_ARRAY_BUFFER, vertices->size() * sizeof(GLfloat), vertices->data(), GL_STATIC_DRAW);
    
    // position
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)0);
    glEnableVertexAttribArray(0);
    
    // color
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
    glEnableVertexAttribArray(1);
    
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
}

void Triangle::Render() {
    glBindVertexArray(vertex_array);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    glBindVertexArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}

std::string Triangle::GetData() {
    std::string temp_data = "";
    // undo aspect ratio stretching
    (*vertices)[1] = (*translated_true_vertices)[1];
    (*vertices)[7] = (*translated_true_vertices)[7];
    (*vertices)[13] = (*translated_true_vertices)[13];

    for (auto vertice : (*vertices)) {
        temp_data += std::to_string(vertice);
        temp_data += ' ';
    }
    //get rid of the last space
    temp_data.pop_back();
    return temp_data;
}

//=============================
// MOVEMENT FUNCTIONS
//=============================

void Triangle::SetPosition(glm::vec3 position, float aspect_ratio) {
    (*translated_true_vertices)[0] = position[0] + (*true_vertices)[0];
    (*translated_true_vertices)[1] = position[1] + (*true_vertices)[1];
    (*translated_true_vertices)[2] = position[2] + (*true_vertices)[2];

    (*translated_true_vertices)[6] = position[0] + (*true_vertices)[6];
    (*translated_true_vertices)[7] = position[1] + (*true_vertices)[7];
    (*translated_true_vertices)[8] = position[2] + (*true_vertices)[8];

    (*translated_true_vertices)[12] = position[0] + (*true_vertices)[12];
    (*translated_true_vertices)[13] = position[1] + (*true_vertices)[13];
    (*translated_true_vertices)[14] = position[2] + (*true_vertices)[14];

    glm::vec3 stretched_position = position;
    stretched_position[1] *= aspect_ratio;

    (*vertices)[0] = stretched_position[0] + (*true_vertices)[0];
    (*vertices)[1] = stretched_position[1] + (*true_vertices)[1];
    (*vertices)[2] = stretched_position[2] + (*true_vertices)[2];

    (*vertices)[6] = stretched_position[0] + (*true_vertices)[6];
    (*vertices)[7] = stretched_position[1] + (*true_vertices)[7];
    (*vertices)[8] = stretched_position[2] + (*true_vertices)[8];

    (*vertices)[12] = stretched_position[0] + (*true_vertices)[12];
    (*vertices)[13] = stretched_position[1] + (*true_vertices)[13];
    (*vertices)[14] = stretched_position[2] + (*true_vertices)[14];
}

//=============================
// COLOR FUNCTIONS
//=============================

void Triangle::SetColor(glm::vec3 color) {
    (*vertices)[3] = color[0];
    (*vertices)[4] = color[1];
    (*vertices)[5] = color[2];
    
    (*vertices)[9] = color[0];
    (*vertices)[10] = color[1];
    (*vertices)[11] = color[2];

    (*vertices)[15] = color[0];
    (*vertices)[16] = color[1];
    (*vertices)[17] = color[2];
}

//=============================
// MEMORY MANAGEMENT
//=============================

void Triangle::FreeAll() {
    glDeleteVertexArrays(1, &vertex_array);
    glDeleteBuffers(1, &vertex_buffer);
    vertex_array = 0;
    vertex_buffer = 0;
}
